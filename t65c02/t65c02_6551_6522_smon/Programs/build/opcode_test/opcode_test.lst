ca65 V2.19 - Git 62da869e4
Main file   : opcode_test.s
Current file: opcode_test.s

000000r 1               ; 65C02 Opcode Stress Test
000000r 1               ; Tests ALL 65C02 opcodes including 65C02-specific instructions
000000r 1               ; Starts at $1000
000000r 1               ; Uses SMON Kernal-style I/O
000000r 1               
000000r 1               .setcpu "65C02"
000000r 1               
000000r 1               ; SMON Kernal I/O vectors
000000r 1               CHROUT = $FFD2          ; Character output
000000r 1               
000000r 1               ; Zero page variables
000000r 1               .segment "ZEROPAGE"
000000r 1  xx xx        zp_temp:     .res 2      ; General temp storage
000002r 1  xx xx        zp_ptr:      .res 2      ; Pointer for indirect addressing
000004r 1  xx xx xx xx  zp_test:     .res 4      ; Test area
000008r 1  xx xx        pass_count:  .res 2      ; Tests passed
00000Ar 1  xx xx        fail_count:  .res 2      ; Tests failed
00000Cr 1  xx xx        str_ptr:     .res 2      ; String pointer
00000Er 1               
00000Er 1               .segment "CODE"
000000r 1               
000000r 1               ; ============================================
000000r 1               ; MAIN ENTRY POINT
000000r 1               ; ============================================
000000r 1               .proc main
000000r 1                       ; Initialize counters
000000r 1  64 rr                stz pass_count
000002r 1  64 rr                stz pass_count+1
000004r 1  64 rr                stz fail_count
000006r 1  64 rr                stz fail_count+1
000008r 1               
000008r 1                       ; Print banner
000008r 1  A9 rr                lda #<banner
00000Ar 1  85 rr                sta str_ptr
00000Cr 1  A9 rr                lda #>banner
00000Er 1  85 rr                sta str_ptr+1
000010r 1  20 rr rr             jsr print_string
000013r 1               
000013r 1                       ; Run all tests
000013r 1  20 rr rr             jsr test_load_store
000016r 1  20 rr rr             jsr test_transfer
000019r 1  20 rr rr             jsr test_stack
00001Cr 1  20 rr rr             jsr test_arithmetic
00001Fr 1  20 rr rr             jsr test_logic
000022r 1  20 rr rr             jsr test_shift
000025r 1  20 rr rr             jsr test_compare
000028r 1  20 rr rr             jsr test_branch
00002Br 1  20 rr rr             jsr test_jump
00002Er 1  20 rr rr             jsr test_flags
000031r 1  20 rr rr             jsr test_65c02_specific
000034r 1  20 rr rr             jsr test_bit_ops
000037r 1  20 rr rr             jsr test_addressing
00003Ar 1               
00003Ar 1                       ; Print results
00003Ar 1  A9 rr                lda #<results
00003Cr 1  85 rr                sta str_ptr
00003Er 1  A9 rr                lda #>results
000040r 1  85 rr                sta str_ptr+1
000042r 1  20 rr rr             jsr print_string
000045r 1               
000045r 1  A5 rr                lda pass_count+1
000047r 1  20 rr rr             jsr print_hex
00004Ar 1  A5 rr                lda pass_count
00004Cr 1  20 rr rr             jsr print_hex
00004Fr 1               
00004Fr 1  A9 rr                lda #<str_passed
000051r 1  85 rr                sta str_ptr
000053r 1  A9 rr                lda #>str_passed
000055r 1  85 rr                sta str_ptr+1
000057r 1  20 rr rr             jsr print_string
00005Ar 1               
00005Ar 1  A5 rr                lda fail_count+1
00005Cr 1  20 rr rr             jsr print_hex
00005Fr 1  A5 rr                lda fail_count
000061r 1  20 rr rr             jsr print_hex
000064r 1               
000064r 1  A9 rr                lda #<str_failed
000066r 1  85 rr                sta str_ptr
000068r 1  A9 rr                lda #>str_failed
00006Ar 1  85 rr                sta str_ptr+1
00006Cr 1  20 rr rr             jsr print_string
00006Fr 1               
00006Fr 1  A9 rr                lda #<footer
000071r 1  85 rr                sta str_ptr
000073r 1  A9 rr                lda #>footer
000075r 1  85 rr                sta str_ptr+1
000077r 1  20 rr rr             jsr print_string
00007Ar 1               
00007Ar 1  00                   brk             ; Return to SMON monitor
00007Br 1  EA                   nop             ; BRK signature byte
00007Cr 1               .endproc
00007Cr 1               
00007Cr 1               ; ============================================
00007Cr 1               ; TEST: Load and Store Instructions
00007Cr 1               ; LDA, LDX, LDY, STA, STX, STY, STZ (65C02)
00007Cr 1               ; ============================================
00007Cr 1               .proc test_load_store
00007Cr 1  A9 rr                lda #<str_load
00007Er 1  85 rr                sta str_ptr
000080r 1  A9 rr                lda #>str_load
000082r 1  85 rr                sta str_ptr+1
000084r 1  20 rr rr             jsr print_string
000087r 1               
000087r 1                       ; LDA immediate
000087r 1  A9 42                lda #$42
000089r 1  C9 42                cmp #$42
00008Br 1  D0 06                bne @fail1
00008Dr 1  20 rr rr             jsr pass
000090r 1  4C rr rr             jmp @t2
000093r 1  20 rr rr     @fail1: jsr fail
000096r 1               
000096r 1               @t2:    ; LDX immediate
000096r 1  A2 55                ldx #$55
000098r 1  E0 55                cpx #$55
00009Ar 1  D0 06                bne @fail2
00009Cr 1  20 rr rr             jsr pass
00009Fr 1  4C rr rr             jmp @t3
0000A2r 1  20 rr rr     @fail2: jsr fail
0000A5r 1               
0000A5r 1               @t3:    ; LDY immediate
0000A5r 1  A0 AA                ldy #$AA
0000A7r 1  C0 AA                cpy #$AA
0000A9r 1  D0 06                bne @fail3
0000ABr 1  20 rr rr             jsr pass
0000AEr 1  4C rr rr             jmp @t4
0000B1r 1  20 rr rr     @fail3: jsr fail
0000B4r 1               
0000B4r 1               @t4:    ; STA zero page
0000B4r 1  A9 12                lda #$12
0000B6r 1  85 rr                sta zp_temp
0000B8r 1  A5 rr                lda zp_temp
0000BAr 1  C9 12                cmp #$12
0000BCr 1  D0 06                bne @fail4
0000BEr 1  20 rr rr             jsr pass
0000C1r 1  4C rr rr             jmp @t5
0000C4r 1  20 rr rr     @fail4: jsr fail
0000C7r 1               
0000C7r 1               @t5:    ; STX zero page
0000C7r 1  A2 34                ldx #$34
0000C9r 1  86 rr                stx zp_temp
0000CBr 1  A5 rr                lda zp_temp
0000CDr 1  C9 34                cmp #$34
0000CFr 1  D0 06                bne @fail5
0000D1r 1  20 rr rr             jsr pass
0000D4r 1  4C rr rr             jmp @t6
0000D7r 1  20 rr rr     @fail5: jsr fail
0000DAr 1               
0000DAr 1               @t6:    ; STY zero page
0000DAr 1  A0 56                ldy #$56
0000DCr 1  84 rr                sty zp_temp
0000DEr 1  A5 rr                lda zp_temp
0000E0r 1  C9 56                cmp #$56
0000E2r 1  D0 06                bne @fail6
0000E4r 1  20 rr rr             jsr pass
0000E7r 1  4C rr rr             jmp @t7
0000EAr 1  20 rr rr     @fail6: jsr fail
0000EDr 1               
0000EDr 1               @t7:    ; STZ zero page (65C02)
0000EDr 1  A9 FF                lda #$FF
0000EFr 1  85 rr                sta zp_temp
0000F1r 1  64 rr                stz zp_temp
0000F3r 1  A5 rr                lda zp_temp
0000F5r 1  D0 06                bne @fail7
0000F7r 1  20 rr rr             jsr pass
0000FAr 1  4C rr rr             jmp @done
0000FDr 1  20 rr rr     @fail7: jsr fail
000100r 1               
000100r 1  A9 0D        @done:  lda #$0D
000102r 1  20 rr rr             jsr print_char
000105r 1  60                   rts
000106r 1               .endproc
000106r 1               
000106r 1               ; ============================================
000106r 1               ; TEST: Transfer Instructions
000106r 1               ; TAX, TAY, TXA, TYA, TSX, TXS
000106r 1               ; ============================================
000106r 1               .proc test_transfer
000106r 1  A9 rr                lda #<str_xfer
000108r 1  85 rr                sta str_ptr
00010Ar 1  A9 rr                lda #>str_xfer
00010Cr 1  85 rr                sta str_ptr+1
00010Er 1  20 rr rr             jsr print_string
000111r 1               
000111r 1                       ; TAX
000111r 1  A9 11                lda #$11
000113r 1  AA                   tax
000114r 1  E0 11                cpx #$11
000116r 1  D0 06                bne @fail1
000118r 1  20 rr rr             jsr pass
00011Br 1  4C rr rr             jmp @t2
00011Er 1  20 rr rr     @fail1: jsr fail
000121r 1               
000121r 1               @t2:    ; TAY
000121r 1  A9 22                lda #$22
000123r 1  A8                   tay
000124r 1  C0 22                cpy #$22
000126r 1  D0 06                bne @fail2
000128r 1  20 rr rr             jsr pass
00012Br 1  4C rr rr             jmp @t3
00012Er 1  20 rr rr     @fail2: jsr fail
000131r 1               
000131r 1               @t3:    ; TXA
000131r 1  A2 33                ldx #$33
000133r 1  8A                   txa
000134r 1  C9 33                cmp #$33
000136r 1  D0 06                bne @fail3
000138r 1  20 rr rr             jsr pass
00013Br 1  4C rr rr             jmp @t4
00013Er 1  20 rr rr     @fail3: jsr fail
000141r 1               
000141r 1               @t4:    ; TYA
000141r 1  A0 44                ldy #$44
000143r 1  98                   tya
000144r 1  C9 44                cmp #$44
000146r 1  D0 06                bne @fail4
000148r 1  20 rr rr             jsr pass
00014Br 1  4C rr rr             jmp @done
00014Er 1  20 rr rr     @fail4: jsr fail
000151r 1               
000151r 1  A9 0D        @done:  lda #$0D
000153r 1  20 rr rr             jsr print_char
000156r 1  60                   rts
000157r 1               .endproc
000157r 1               
000157r 1               ; ============================================
000157r 1               ; TEST: Stack Instructions
000157r 1               ; PHA, PLA, PHX, PLX, PHY, PLY (65C02)
000157r 1               ; ============================================
000157r 1               .proc test_stack
000157r 1  A9 rr                lda #<str_stack
000159r 1  85 rr                sta str_ptr
00015Br 1  A9 rr                lda #>str_stack
00015Dr 1  85 rr                sta str_ptr+1
00015Fr 1  20 rr rr             jsr print_string
000162r 1               
000162r 1                       ; PHA/PLA
000162r 1  A9 77                lda #$77
000164r 1  48                   pha
000165r 1  A9 00                lda #$00
000167r 1  68                   pla
000168r 1  C9 77                cmp #$77
00016Ar 1  D0 06                bne @fail1
00016Cr 1  20 rr rr             jsr pass
00016Fr 1  4C rr rr             jmp @t2
000172r 1  20 rr rr     @fail1: jsr fail
000175r 1               
000175r 1               @t2:    ; PHX/PLX (65C02)
000175r 1  A2 88                ldx #$88
000177r 1  DA                   phx
000178r 1  A2 00                ldx #$00
00017Ar 1  FA                   plx
00017Br 1  E0 88                cpx #$88
00017Dr 1  D0 06                bne @fail2
00017Fr 1  20 rr rr             jsr pass
000182r 1  4C rr rr             jmp @t3
000185r 1  20 rr rr     @fail2: jsr fail
000188r 1               
000188r 1               @t3:    ; PHY/PLY (65C02)
000188r 1  A0 99                ldy #$99
00018Ar 1  5A                   phy
00018Br 1  A0 00                ldy #$00
00018Dr 1  7A                   ply
00018Er 1  C0 99                cpy #$99
000190r 1  D0 06                bne @fail3
000192r 1  20 rr rr             jsr pass
000195r 1  4C rr rr             jmp @done
000198r 1  20 rr rr     @fail3: jsr fail
00019Br 1               
00019Br 1  A9 0D        @done:  lda #$0D
00019Dr 1  20 rr rr             jsr print_char
0001A0r 1  60                   rts
0001A1r 1               .endproc
0001A1r 1               
0001A1r 1               ; ============================================
0001A1r 1               ; TEST: Arithmetic Instructions
0001A1r 1               ; ADC, SBC, INC, DEC, INX, INY, DEX, DEY
0001A1r 1               ; ============================================
0001A1r 1               .proc test_arithmetic
0001A1r 1  A9 rr                lda #<str_arith
0001A3r 1  85 rr                sta str_ptr
0001A5r 1  A9 rr                lda #>str_arith
0001A7r 1  85 rr                sta str_ptr+1
0001A9r 1  20 rr rr             jsr print_string
0001ACr 1               
0001ACr 1                       ; ADC
0001ACr 1  18                   clc
0001ADr 1  A9 10                lda #$10
0001AFr 1  69 20                adc #$20
0001B1r 1  C9 30                cmp #$30
0001B3r 1  D0 06                bne @fail1
0001B5r 1  20 rr rr             jsr pass
0001B8r 1  4C rr rr             jmp @t2
0001BBr 1  20 rr rr     @fail1: jsr fail
0001BEr 1               
0001BEr 1               @t2:    ; SBC
0001BEr 1  38                   sec
0001BFr 1  A9 50                lda #$50
0001C1r 1  E9 20                sbc #$20
0001C3r 1  C9 30                cmp #$30
0001C5r 1  D0 06                bne @fail2
0001C7r 1  20 rr rr             jsr pass
0001CAr 1  4C rr rr             jmp @t3
0001CDr 1  20 rr rr     @fail2: jsr fail
0001D0r 1               
0001D0r 1               @t3:    ; INC A (65C02)
0001D0r 1  A9 FE                lda #$FE
0001D2r 1  1A                   inc a
0001D3r 1  C9 FF                cmp #$FF
0001D5r 1  D0 06                bne @fail3
0001D7r 1  20 rr rr             jsr pass
0001DAr 1  4C rr rr             jmp @t4
0001DDr 1  20 rr rr     @fail3: jsr fail
0001E0r 1               
0001E0r 1               @t4:    ; DEC A (65C02)
0001E0r 1  A9 02                lda #$02
0001E2r 1  3A                   dec a
0001E3r 1  C9 01                cmp #$01
0001E5r 1  D0 06                bne @fail4
0001E7r 1  20 rr rr             jsr pass
0001EAr 1  4C rr rr             jmp @t5
0001EDr 1  20 rr rr     @fail4: jsr fail
0001F0r 1               
0001F0r 1               @t5:    ; INX
0001F0r 1  A2 10                ldx #$10
0001F2r 1  E8                   inx
0001F3r 1  E0 11                cpx #$11
0001F5r 1  D0 06                bne @fail5
0001F7r 1  20 rr rr             jsr pass
0001FAr 1  4C rr rr             jmp @t6
0001FDr 1  20 rr rr     @fail5: jsr fail
000200r 1               
000200r 1               @t6:    ; DEX
000200r 1  A2 10                ldx #$10
000202r 1  CA                   dex
000203r 1  E0 0F                cpx #$0F
000205r 1  D0 06                bne @fail6
000207r 1  20 rr rr             jsr pass
00020Ar 1  4C rr rr             jmp @t7
00020Dr 1  20 rr rr     @fail6: jsr fail
000210r 1               
000210r 1               @t7:    ; INY
000210r 1  A0 20                ldy #$20
000212r 1  C8                   iny
000213r 1  C0 21                cpy #$21
000215r 1  D0 06                bne @fail7
000217r 1  20 rr rr             jsr pass
00021Ar 1  4C rr rr             jmp @t8
00021Dr 1  20 rr rr     @fail7: jsr fail
000220r 1               
000220r 1               @t8:    ; DEY
000220r 1  A0 20                ldy #$20
000222r 1  88                   dey
000223r 1  C0 1F                cpy #$1F
000225r 1  D0 06                bne @fail8
000227r 1  20 rr rr             jsr pass
00022Ar 1  4C rr rr             jmp @done
00022Dr 1  20 rr rr     @fail8: jsr fail
000230r 1               
000230r 1  A9 0D        @done:  lda #$0D
000232r 1  20 rr rr             jsr print_char
000235r 1  60                   rts
000236r 1               .endproc
000236r 1               
000236r 1               ; ============================================
000236r 1               ; TEST: Logic Instructions
000236r 1               ; AND, ORA, EOR
000236r 1               ; ============================================
000236r 1               .proc test_logic
000236r 1  A9 rr                lda #<str_logic
000238r 1  85 rr                sta str_ptr
00023Ar 1  A9 rr                lda #>str_logic
00023Cr 1  85 rr                sta str_ptr+1
00023Er 1  20 rr rr             jsr print_string
000241r 1               
000241r 1                       ; AND
000241r 1  A9 FF                lda #$FF
000243r 1  29 0F                and #$0F
000245r 1  C9 0F                cmp #$0F
000247r 1  D0 06                bne @fail1
000249r 1  20 rr rr             jsr pass
00024Cr 1  4C rr rr             jmp @t2
00024Fr 1  20 rr rr     @fail1: jsr fail
000252r 1               
000252r 1               @t2:    ; ORA
000252r 1  A9 F0                lda #$F0
000254r 1  09 0F                ora #$0F
000256r 1  C9 FF                cmp #$FF
000258r 1  D0 06                bne @fail2
00025Ar 1  20 rr rr             jsr pass
00025Dr 1  4C rr rr             jmp @t3
000260r 1  20 rr rr     @fail2: jsr fail
000263r 1               
000263r 1               @t3:    ; EOR
000263r 1  A9 AA                lda #$AA
000265r 1  49 FF                eor #$FF
000267r 1  C9 55                cmp #$55
000269r 1  D0 06                bne @fail3
00026Br 1  20 rr rr             jsr pass
00026Er 1  4C rr rr             jmp @done
000271r 1  20 rr rr     @fail3: jsr fail
000274r 1               
000274r 1  A9 0D        @done:  lda #$0D
000276r 1  20 rr rr             jsr print_char
000279r 1  60                   rts
00027Ar 1               .endproc
00027Ar 1               
00027Ar 1               ; ============================================
00027Ar 1               ; TEST: Shift/Rotate Instructions
00027Ar 1               ; ASL, LSR, ROL, ROR
00027Ar 1               ; ============================================
00027Ar 1               .proc test_shift
00027Ar 1  A9 rr                lda #<str_shift
00027Cr 1  85 rr                sta str_ptr
00027Er 1  A9 rr                lda #>str_shift
000280r 1  85 rr                sta str_ptr+1
000282r 1  20 rr rr             jsr print_string
000285r 1               
000285r 1                       ; ASL
000285r 1  A9 40                lda #$40
000287r 1  0A                   asl a
000288r 1  C9 80                cmp #$80
00028Ar 1  D0 06                bne @fail1
00028Cr 1  20 rr rr             jsr pass
00028Fr 1  4C rr rr             jmp @t2
000292r 1  20 rr rr     @fail1: jsr fail
000295r 1               
000295r 1               @t2:    ; LSR
000295r 1  A9 80                lda #$80
000297r 1  4A                   lsr a
000298r 1  C9 40                cmp #$40
00029Ar 1  D0 06                bne @fail2
00029Cr 1  20 rr rr             jsr pass
00029Fr 1  4C rr rr             jmp @t3
0002A2r 1  20 rr rr     @fail2: jsr fail
0002A5r 1               
0002A5r 1               @t3:    ; ROL (with carry)
0002A5r 1  38                   sec
0002A6r 1  A9 40                lda #$40
0002A8r 1  2A                   rol a
0002A9r 1  C9 81                cmp #$81
0002ABr 1  D0 06                bne @fail3
0002ADr 1  20 rr rr             jsr pass
0002B0r 1  4C rr rr             jmp @t4
0002B3r 1  20 rr rr     @fail3: jsr fail
0002B6r 1               
0002B6r 1               @t4:    ; ROR (with carry)
0002B6r 1  38                   sec
0002B7r 1  A9 02                lda #$02
0002B9r 1  6A                   ror a
0002BAr 1  C9 81                cmp #$81
0002BCr 1  D0 06                bne @fail4
0002BEr 1  20 rr rr             jsr pass
0002C1r 1  4C rr rr             jmp @done
0002C4r 1  20 rr rr     @fail4: jsr fail
0002C7r 1               
0002C7r 1  A9 0D        @done:  lda #$0D
0002C9r 1  20 rr rr             jsr print_char
0002CCr 1  60                   rts
0002CDr 1               .endproc
0002CDr 1               
0002CDr 1               ; ============================================
0002CDr 1               ; TEST: Compare Instructions
0002CDr 1               ; CMP, CPX, CPY
0002CDr 1               ; ============================================
0002CDr 1               .proc test_compare
0002CDr 1  A9 rr                lda #<str_cmp
0002CFr 1  85 rr                sta str_ptr
0002D1r 1  A9 rr                lda #>str_cmp
0002D3r 1  85 rr                sta str_ptr+1
0002D5r 1  20 rr rr             jsr print_string
0002D8r 1               
0002D8r 1                       ; CMP equal
0002D8r 1  A9 50                lda #$50
0002DAr 1  C9 50                cmp #$50
0002DCr 1  D0 06                bne @fail1
0002DEr 1  20 rr rr             jsr pass
0002E1r 1  4C rr rr             jmp @t2
0002E4r 1  20 rr rr     @fail1: jsr fail
0002E7r 1               
0002E7r 1               @t2:    ; CMP greater
0002E7r 1  A9 60                lda #$60
0002E9r 1  C9 50                cmp #$50
0002EBr 1  90 06                bcc @fail2
0002EDr 1  20 rr rr             jsr pass
0002F0r 1  4C rr rr             jmp @t3
0002F3r 1  20 rr rr     @fail2: jsr fail
0002F6r 1               
0002F6r 1               @t3:    ; CPX
0002F6r 1  A2 30                ldx #$30
0002F8r 1  E0 30                cpx #$30
0002FAr 1  D0 06                bne @fail3
0002FCr 1  20 rr rr             jsr pass
0002FFr 1  4C rr rr             jmp @t4
000302r 1  20 rr rr     @fail3: jsr fail
000305r 1               
000305r 1               @t4:    ; CPY
000305r 1  A0 40                ldy #$40
000307r 1  C0 40                cpy #$40
000309r 1  D0 06                bne @fail4
00030Br 1  20 rr rr             jsr pass
00030Er 1  4C rr rr             jmp @done
000311r 1  20 rr rr     @fail4: jsr fail
000314r 1               
000314r 1  A9 0D        @done:  lda #$0D
000316r 1  20 rr rr             jsr print_char
000319r 1  60                   rts
00031Ar 1               .endproc
00031Ar 1               
00031Ar 1               ; ============================================
00031Ar 1               ; TEST: Branch Instructions
00031Ar 1               ; BEQ, BNE, BCS, BCC, BMI, BPL, BVS, BVC, BRA
00031Ar 1               ; ============================================
00031Ar 1               .proc test_branch
00031Ar 1  A9 rr                lda #<str_branch
00031Cr 1  85 rr                sta str_ptr
00031Er 1  A9 rr                lda #>str_branch
000320r 1  85 rr                sta str_ptr+1
000322r 1  20 rr rr             jsr print_string
000325r 1               
000325r 1                       ; BEQ
000325r 1  A9 00                lda #$00
000327r 1  F0 06                beq @ok1
000329r 1  20 rr rr             jsr fail
00032Cr 1  4C rr rr             jmp @t2
00032Fr 1  20 rr rr     @ok1:   jsr pass
000332r 1               
000332r 1               @t2:    ; BNE
000332r 1  A9 01                lda #$01
000334r 1  D0 06                bne @ok2
000336r 1  20 rr rr             jsr fail
000339r 1  4C rr rr             jmp @t3
00033Cr 1  20 rr rr     @ok2:   jsr pass
00033Fr 1               
00033Fr 1               @t3:    ; BCS
00033Fr 1  38                   sec
000340r 1  B0 06                bcs @ok3
000342r 1  20 rr rr             jsr fail
000345r 1  4C rr rr             jmp @t4
000348r 1  20 rr rr     @ok3:   jsr pass
00034Br 1               
00034Br 1               @t4:    ; BCC
00034Br 1  18                   clc
00034Cr 1  90 06                bcc @ok4
00034Er 1  20 rr rr             jsr fail
000351r 1  4C rr rr             jmp @t5
000354r 1  20 rr rr     @ok4:   jsr pass
000357r 1               
000357r 1               @t5:    ; BMI
000357r 1  A9 80                lda #$80
000359r 1  30 06                bmi @ok5
00035Br 1  20 rr rr             jsr fail
00035Er 1  4C rr rr             jmp @t6
000361r 1  20 rr rr     @ok5:   jsr pass
000364r 1               
000364r 1               @t6:    ; BPL
000364r 1  A9 7F                lda #$7F
000366r 1  10 06                bpl @ok6
000368r 1  20 rr rr             jsr fail
00036Br 1  4C rr rr             jmp @t7
00036Er 1  20 rr rr     @ok6:   jsr pass
000371r 1               
000371r 1               @t7:    ; BRA (65C02) - always branches
000371r 1  80 06                bra @ok7
000373r 1  20 rr rr             jsr fail
000376r 1  4C rr rr             jmp @done
000379r 1  20 rr rr     @ok7:   jsr pass
00037Cr 1               
00037Cr 1  A9 0D        @done:  lda #$0D
00037Er 1  20 rr rr             jsr print_char
000381r 1  60                   rts
000382r 1               .endproc
000382r 1               
000382r 1               ; ============================================
000382r 1               ; TEST: Jump Instructions
000382r 1               ; JMP, JSR, RTS
000382r 1               ; ============================================
000382r 1               .proc test_jump
000382r 1  A9 rr                lda #<str_jump
000384r 1  85 rr                sta str_ptr
000386r 1  A9 rr                lda #>str_jump
000388r 1  85 rr                sta str_ptr+1
00038Ar 1  20 rr rr             jsr print_string
00038Dr 1               
00038Dr 1                       ; JMP absolute
00038Dr 1  4C rr rr             jmp @ok1
000390r 1  20 rr rr     @fail1: jsr fail
000393r 1  4C rr rr             jmp @t2
000396r 1  20 rr rr     @ok1:   jsr pass
000399r 1               
000399r 1               @t2:    ; JSR/RTS
000399r 1  20 rr rr             jsr @sub1
00039Cr 1  20 rr rr             jsr pass
00039Fr 1  4C rr rr             jmp @t3
0003A2r 1               
0003A2r 1  60           @sub1:  rts
0003A3r 1               
0003A3r 1               @t3:    ; JMP indirect (also tests addressing mode)
0003A3r 1  A9 rr                lda #<@ok3
0003A5r 1  85 rr                sta zp_ptr
0003A7r 1  A9 rr                lda #>@ok3
0003A9r 1  85 rr                sta zp_ptr+1
0003ABr 1  6C rr rr             jmp (zp_ptr)
0003AEr 1  20 rr rr     @fail3: jsr fail
0003B1r 1  4C rr rr             jmp @done
0003B4r 1  20 rr rr     @ok3:   jsr pass
0003B7r 1               
0003B7r 1  A9 0D        @done:  lda #$0D
0003B9r 1  20 rr rr             jsr print_char
0003BCr 1  60                   rts
0003BDr 1               .endproc
0003BDr 1               
0003BDr 1               ; ============================================
0003BDr 1               ; TEST: Flag Instructions
0003BDr 1               ; SEC, CLC, SEI, CLI, SED, CLD, CLV
0003BDr 1               ; ============================================
0003BDr 1               .proc test_flags
0003BDr 1  A9 rr                lda #<str_flags
0003BFr 1  85 rr                sta str_ptr
0003C1r 1  A9 rr                lda #>str_flags
0003C3r 1  85 rr                sta str_ptr+1
0003C5r 1  20 rr rr             jsr print_string
0003C8r 1               
0003C8r 1                       ; SEC/CLC
0003C8r 1  38                   sec
0003C9r 1  90 09                bcc @fail1
0003CBr 1  18                   clc
0003CCr 1  B0 06                bcs @fail1
0003CEr 1  20 rr rr             jsr pass
0003D1r 1  4C rr rr             jmp @t2
0003D4r 1  20 rr rr     @fail1: jsr fail
0003D7r 1               
0003D7r 1               @t2:    ; CLD (Decimal mode should be clear)
0003D7r 1  D8                   cld
0003D8r 1  20 rr rr             jsr pass
0003DBr 1               
0003DBr 1                       ; PHP/PLP test
0003DBr 1  38                   sec
0003DCr 1  08                   php
0003DDr 1  18                   clc
0003DEr 1  28                   plp
0003DFr 1  90 06                bcc @fail3
0003E1r 1  20 rr rr             jsr pass
0003E4r 1  4C rr rr             jmp @done
0003E7r 1  20 rr rr     @fail3: jsr fail
0003EAr 1               
0003EAr 1  A9 0D        @done:  lda #$0D
0003ECr 1  20 rr rr             jsr print_char
0003EFr 1  60                   rts
0003F0r 1               .endproc
0003F0r 1               
0003F0r 1               ; ============================================
0003F0r 1               ; TEST: 65C02-Specific Instructions
0003F0r 1               ; STZ, BRA, PHX, PLX, PHY, PLY, INC A, DEC A
0003F0r 1               ; TRB, TSB
0003F0r 1               ; ============================================
0003F0r 1               .proc test_65c02_specific
0003F0r 1  A9 rr                lda #<str_65c02
0003F2r 1  85 rr                sta str_ptr
0003F4r 1  A9 rr                lda #>str_65c02
0003F6r 1  85 rr                sta str_ptr+1
0003F8r 1  20 rr rr             jsr print_string
0003FBr 1               
0003FBr 1                       ; TRB (Test and Reset Bits)
0003FBr 1  A9 FF                lda #$FF
0003FDr 1  85 rr                sta zp_temp
0003FFr 1  A9 0F                lda #$0F
000401r 1  14 rr                trb zp_temp     ; Clear bits 0-3
000403r 1  A5 rr                lda zp_temp
000405r 1  C9 F0                cmp #$F0
000407r 1  D0 06                bne @fail1
000409r 1  20 rr rr             jsr pass
00040Cr 1  4C rr rr             jmp @t2
00040Fr 1  20 rr rr     @fail1: jsr fail
000412r 1               
000412r 1               @t2:    ; TSB (Test and Set Bits)
000412r 1  A9 00                lda #$00
000414r 1  85 rr                sta zp_temp
000416r 1  A9 0F                lda #$0F
000418r 1  04 rr                tsb zp_temp     ; Set bits 0-3
00041Ar 1  A5 rr                lda zp_temp
00041Cr 1  C9 0F                cmp #$0F
00041Er 1  D0 06                bne @fail2
000420r 1  20 rr rr             jsr pass
000423r 1  4C rr rr             jmp @t3
000426r 1  20 rr rr     @fail2: jsr fail
000429r 1               
000429r 1               @t3:    ; JMP (indirect,x) - 65C02 indexed indirect jump
000429r 1  A2 00                ldx #$00
00042Br 1  A9 rr                lda #<@ok3
00042Dr 1  85 rr                sta zp_ptr
00042Fr 1  A9 rr                lda #>@ok3
000431r 1  85 rr                sta zp_ptr+1
000433r 1  7C rr rr             jmp (zp_ptr,x)
000436r 1  20 rr rr     @fail3: jsr fail
000439r 1  4C rr rr             jmp @done
00043Cr 1  20 rr rr     @ok3:   jsr pass
00043Fr 1               
00043Fr 1  A9 0D        @done:  lda #$0D
000441r 1  20 rr rr             jsr print_char
000444r 1  60                   rts
000445r 1               .endproc
000445r 1               
000445r 1               ; ============================================
000445r 1               ; TEST: BIT Instruction
000445r 1               ; BIT immediate (65C02), BIT zp, BIT abs
000445r 1               ; ============================================
000445r 1               .proc test_bit_ops
000445r 1  A9 rr                lda #<str_bit
000447r 1  85 rr                sta str_ptr
000449r 1  A9 rr                lda #>str_bit
00044Br 1  85 rr                sta str_ptr+1
00044Dr 1  20 rr rr             jsr print_string
000450r 1               
000450r 1                       ; BIT immediate (65C02)
000450r 1  A9 FF                lda #$FF
000452r 1  89 0F                bit #$0F
000454r 1  F0 06                beq @fail1
000456r 1  20 rr rr             jsr pass
000459r 1  4C rr rr             jmp @t2
00045Cr 1  20 rr rr     @fail1: jsr fail
00045Fr 1               
00045Fr 1               @t2:    ; BIT zero page
00045Fr 1  A9 80                lda #$80
000461r 1  85 rr                sta zp_temp
000463r 1  24 rr                bit zp_temp
000465r 1  10 06                bpl @fail2      ; N flag should be set
000467r 1  20 rr rr             jsr pass
00046Ar 1  4C rr rr             jmp @t3
00046Dr 1  20 rr rr     @fail2: jsr fail
000470r 1               
000470r 1               @t3:    ; BIT zero page (V flag)
000470r 1  A9 40                lda #$40
000472r 1  85 rr                sta zp_temp
000474r 1  24 rr                bit zp_temp
000476r 1  50 06                bvc @fail3      ; V flag should be set
000478r 1  20 rr rr             jsr pass
00047Br 1  4C rr rr             jmp @done
00047Er 1  20 rr rr     @fail3: jsr fail
000481r 1               
000481r 1  A9 0D        @done:  lda #$0D
000483r 1  20 rr rr             jsr print_char
000486r 1  60                   rts
000487r 1               .endproc
000487r 1               
000487r 1               ; ============================================
000487r 1               ; TEST: Addressing Modes
000487r 1               ; (zp,x), (zp),y, (zp) - 65C02
000487r 1               ; ============================================
000487r 1               .proc test_addressing
000487r 1  A9 rr                lda #<str_addr
000489r 1  85 rr                sta str_ptr
00048Br 1  A9 rr                lda #>str_addr
00048Dr 1  85 rr                sta str_ptr+1
00048Fr 1  20 rr rr             jsr print_string
000492r 1               
000492r 1                       ; Set up test data
000492r 1  A9 rr                lda #<test_data
000494r 1  85 rr                sta zp_ptr
000496r 1  A9 rr                lda #>test_data
000498r 1  85 rr                sta zp_ptr+1
00049Ar 1               
00049Ar 1                       ; (zp),y indirect indexed
00049Ar 1  A0 00                ldy #$00
00049Cr 1  B1 rr                lda (zp_ptr),y
00049Er 1  C9 11                cmp #$11
0004A0r 1  D0 06                bne @fail1
0004A2r 1  20 rr rr             jsr pass
0004A5r 1  4C rr rr             jmp @t2
0004A8r 1  20 rr rr     @fail1: jsr fail
0004ABr 1               
0004ABr 1               @t2:    ; (zp),y with offset
0004ABr 1  A0 01                ldy #$01
0004ADr 1  B1 rr                lda (zp_ptr),y
0004AFr 1  C9 22                cmp #$22
0004B1r 1  D0 06                bne @fail2
0004B3r 1  20 rr rr             jsr pass
0004B6r 1  4C rr rr             jmp @t3
0004B9r 1  20 rr rr     @fail2: jsr fail
0004BCr 1               
0004BCr 1               @t3:    ; (zp) - 65C02 indirect without index
0004BCr 1  B2 rr                lda (zp_ptr)
0004BEr 1  C9 11                cmp #$11
0004C0r 1  D0 06                bne @fail3
0004C2r 1  20 rr rr             jsr pass
0004C5r 1  4C rr rr             jmp @done
0004C8r 1  20 rr rr     @fail3: jsr fail
0004CBr 1               
0004CBr 1  A9 0D        @done:  lda #$0D
0004CDr 1  20 rr rr             jsr print_char
0004D0r 1  60                   rts
0004D1r 1               .endproc
0004D1r 1               
0004D1r 1               ; ============================================
0004D1r 1               ; HELPER: Print pass marker
0004D1r 1               ; ============================================
0004D1r 1               .proc pass
0004D1r 1  A9 2E                lda #'.'
0004D3r 1  20 rr rr             jsr print_char
0004D6r 1  E6 rr                inc pass_count
0004D8r 1  D0 02                bne @done
0004DAr 1  E6 rr                inc pass_count+1
0004DCr 1  60           @done:  rts
0004DDr 1               .endproc
0004DDr 1               
0004DDr 1               ; ============================================
0004DDr 1               ; HELPER: Print fail marker
0004DDr 1               ; ============================================
0004DDr 1               .proc fail
0004DDr 1  A9 58                lda #'X'
0004DFr 1  20 rr rr             jsr print_char
0004E2r 1  E6 rr                inc fail_count
0004E4r 1  D0 02                bne @done
0004E6r 1  E6 rr                inc fail_count+1
0004E8r 1  60           @done:  rts
0004E9r 1               .endproc
0004E9r 1               
0004E9r 1               ; ============================================
0004E9r 1               ; HELPER: Print hex byte in A
0004E9r 1               ; ============================================
0004E9r 1               .proc print_hex
0004E9r 1  48                   pha
0004EAr 1  4A                   lsr a
0004EBr 1  4A                   lsr a
0004ECr 1  4A                   lsr a
0004EDr 1  4A                   lsr a
0004EEr 1  20 rr rr             jsr @nibble
0004F1r 1  68                   pla
0004F2r 1  29 0F                and #$0F
0004F4r 1               @nibble:
0004F4r 1  C9 0A                cmp #10
0004F6r 1  90 02                bcc @digit
0004F8r 1  69 06                adc #6
0004FAr 1  69 30        @digit: adc #'0'
0004FCr 1  20 rr rr             jsr print_char
0004FFr 1  60                   rts
000500r 1               .endproc
000500r 1               
000500r 1               ; ============================================
000500r 1               ; HELPER: Print character in A
000500r 1               ; ============================================
000500r 1               .proc print_char
000500r 1  20 D2 FF             jsr CHROUT
000503r 1  60                   rts
000504r 1               .endproc
000504r 1               
000504r 1               ; ============================================
000504r 1               ; HELPER: Print null-terminated string
000504r 1               ; ============================================
000504r 1               .proc print_string
000504r 1  A0 00                ldy #0
000506r 1               @loop:
000506r 1  B1 rr                lda (str_ptr),y
000508r 1  F0 06                beq @done
00050Ar 1  20 D2 FF             jsr CHROUT
00050Dr 1  C8                   iny
00050Er 1  D0 F6                bne @loop
000510r 1  60           @done:  rts
000511r 1               .endproc
000511r 1               
000511r 1               ; ============================================
000511r 1               ; DATA SECTION
000511r 1               ; ============================================
000511r 1               test_data:
000511r 1  11 22 33 44          .byte $11, $22, $33, $44
000515r 1               
000515r 1               banner:
000515r 1  0D 3D 3D 3D          .byte $0D, "================================", $0D
000519r 1  3D 3D 3D 3D  
00051Dr 1  3D 3D 3D 3D  
000537r 1  20 20 36 35          .byte "  65C02 OPCODE TEST", $0D
00053Br 1  43 30 32 20  
00053Fr 1  4F 50 43 4F  
00054Br 1  20 20 54 65          .byte "  Testing all instructions", $0D
00054Fr 1  73 74 69 6E  
000553r 1  67 20 61 6C  
000566r 1  3D 3D 3D 3D          .byte "================================", $0D, $0D, 0
00056Ar 1  3D 3D 3D 3D  
00056Er 1  3D 3D 3D 3D  
000589r 1               
000589r 1               str_load:
000589r 1  4C 6F 61 64          .byte "Load/Store: ", 0
00058Dr 1  2F 53 74 6F  
000591r 1  72 65 3A 20  
000596r 1               str_xfer:
000596r 1  54 72 61 6E          .byte "Transfer:   ", 0
00059Ar 1  73 66 65 72  
00059Er 1  3A 20 20 20  
0005A3r 1               str_stack:
0005A3r 1  53 74 61 63          .byte "Stack:      ", 0
0005A7r 1  6B 3A 20 20  
0005ABr 1  20 20 20 20  
0005B0r 1               str_arith:
0005B0r 1  41 72 69 74          .byte "Arithmetic: ", 0
0005B4r 1  68 6D 65 74  
0005B8r 1  69 63 3A 20  
0005BDr 1               str_logic:
0005BDr 1  4C 6F 67 69          .byte "Logic:      ", 0
0005C1r 1  63 3A 20 20  
0005C5r 1  20 20 20 20  
0005CAr 1               str_shift:
0005CAr 1  53 68 69 66          .byte "Shift/Rot:  ", 0
0005CEr 1  74 2F 52 6F  
0005D2r 1  74 3A 20 20  
0005D7r 1               str_cmp:
0005D7r 1  43 6F 6D 70          .byte "Compare:    ", 0
0005DBr 1  61 72 65 3A  
0005DFr 1  20 20 20 20  
0005E4r 1               str_branch:
0005E4r 1  42 72 61 6E          .byte "Branch:     ", 0
0005E8r 1  63 68 3A 20  
0005ECr 1  20 20 20 20  
0005F1r 1               str_jump:
0005F1r 1  4A 75 6D 70          .byte "Jump:       ", 0
0005F5r 1  3A 20 20 20  
0005F9r 1  20 20 20 20  
0005FEr 1               str_flags:
0005FEr 1  46 6C 61 67          .byte "Flags:      ", 0
000602r 1  73 3A 20 20  
000606r 1  20 20 20 20  
00060Br 1               str_65c02:
00060Br 1  36 35 43 30          .byte "65C02 Ext:  ", 0
00060Fr 1  32 20 45 78  
000613r 1  74 3A 20 20  
000618r 1               str_bit:
000618r 1  42 49 54 3A          .byte "BIT:        ", 0
00061Cr 1  20 20 20 20  
000620r 1  20 20 20 20  
000625r 1               str_addr:
000625r 1  41 64 64 72          .byte "Addressing: ", 0
000629r 1  65 73 73 69  
00062Dr 1  6E 67 3A 20  
000632r 1               
000632r 1               results:
000632r 1  0D 3D 3D 3D          .byte $0D, "================================", $0D
000636r 1  3D 3D 3D 3D  
00063Ar 1  3D 3D 3D 3D  
000654r 1  54 45 53 54          .byte "TEST RESULTS:", $0D
000658r 1  20 52 45 53  
00065Cr 1  55 4C 54 53  
000662r 1  20 20 50 61          .byte "  Passed: $", 0
000666r 1  73 73 65 64  
00066Ar 1  3A 20 24 00  
00066Er 1               
00066Er 1               str_passed:
00066Er 1  0D 20 20 46          .byte $0D, "  Failed: $", 0
000672r 1  61 69 6C 65  
000676r 1  64 3A 20 24  
00067Br 1               
00067Br 1               str_failed:
00067Br 1  0D 00                .byte $0D, 0
00067Dr 1               
00067Dr 1               footer:
00067Dr 1  3D 3D 3D 3D          .byte "================================", $0D
000681r 1  3D 3D 3D 3D  
000685r 1  3D 3D 3D 3D  
00069Er 1  36 35 43 30          .byte "65C02 opcode coverage test", $0D
0006A2r 1  32 20 6F 70  
0006A6r 1  63 6F 64 65  
0006B9r 1  0D 00                .byte $0D, 0
0006BAr 1               

ca65 V2.19 - Git 62da869e4
Main file   : memsort.s
Current file: memsort.s

000000r 1               ; Memory Sort Stress Test for 65C02
000000r 1               ; Starts at $1000
000000r 1               ; Uses SMON Kernal-style I/O
000000r 1               ; Fills memory with random data, then sorts it using multiple algorithms
000000r 1               ; INTENSIVE: Tests memory, ALU, branching, addressing modes
000000r 1               
000000r 1               .setcpu "65C02"
000000r 1               
000000r 1               ; SMON Kernal I/O vectors
000000r 1               CHROUT = $FFD2          ; Character output
000000r 1               
000000r 1               ; Configuration
000000r 1               ARRAY_SIZE = 255        ; Size of array to sort (smaller for testing)
000000r 1               ARRAY_BASE = $0200      ; Array location in RAM (page 2, safe area)
000000r 1               
000000r 1               ; Zero page variables
000000r 1               .segment "ZEROPAGE"
000000r 1  xx xx        rand_seed:   .res 2      ; 16-bit LFSR seed
000002r 1  xx xx        ptr1:        .res 2      ; General pointer
000004r 1  xx xx        ptr2:        .res 2      ; Second pointer
000006r 1  xx           temp:        .res 1      ; Temp storage
000007r 1  xx           temp2:       .res 1      ; Second temp
000008r 1  xx xx        swap_count:  .res 2      ; Number of swaps (16-bit)
00000Ar 1  xx xx        pass_count:  .res 2      ; Number of passes
00000Cr 1  xx xx xx xx  compare_cnt: .res 4      ; Comparison count (32-bit)
000010r 1  xx xx        str_ptr:     .res 2      ; String pointer
000012r 1  xx           min_idx:     .res 1      ; For selection sort
000013r 1  xx           i_idx:       .res 1      ; Outer loop index
000014r 1  xx           j_idx:       .res 1      ; Inner loop index
000015r 1  xx           gap:         .res 1      ; For shell sort
000016r 1  xx xx        dump_ptr:    .res 2      ; Pointer for hex dump
000018r 1  xx           dump_cnt:    .res 1      ; Counter for hex dump
000019r 1               
000019r 1               .segment "CODE"
000000r 1               
000000r 1               ; ============================================
000000r 1               ; MAIN ENTRY POINT
000000r 1               ; ============================================
000000r 1               .proc main
000000r 1                       ; Initialize random seed if zero
000000r 1  A5 rr                lda rand_seed
000002r 1  05 rr                ora rand_seed+1
000004r 1  D0 08                bne @has_seed
000006r 1  A9 DE                lda #$DE
000008r 1  85 rr                sta rand_seed
00000Ar 1  A9 AD                lda #$AD
00000Cr 1  85 rr                sta rand_seed+1
00000Er 1               @has_seed:
00000Er 1               
00000Er 1                       ; Print banner
00000Er 1  A9 rr                lda #<banner
000010r 1  85 rr                sta str_ptr
000012r 1  A9 rr                lda #>banner
000014r 1  85 rr                sta str_ptr+1
000016r 1  20 rr rr             jsr print_string
000019r 1               
000019r 1                       ; ========== TEST 1: BUBBLE SORT ==========
000019r 1  A9 rr                lda #<str_bubble
00001Br 1  85 rr                sta str_ptr
00001Dr 1  A9 rr                lda #>str_bubble
00001Fr 1  85 rr                sta str_ptr+1
000021r 1  20 rr rr             jsr print_string
000024r 1               
000024r 1  20 rr rr             jsr fill_random
000027r 1               
000027r 1  A9 rr                lda #<str_before
000029r 1  85 rr                sta str_ptr
00002Br 1  A9 rr                lda #>str_before
00002Dr 1  85 rr                sta str_ptr+1
00002Fr 1  20 rr rr             jsr print_string
000032r 1  20 rr rr             jsr hex_dump
000035r 1               
000035r 1  20 rr rr             jsr bubble_sort
000038r 1               
000038r 1  A9 rr                lda #<str_after
00003Ar 1  85 rr                sta str_ptr
00003Cr 1  A9 rr                lda #>str_after
00003Er 1  85 rr                sta str_ptr+1
000040r 1  20 rr rr             jsr print_string
000043r 1  20 rr rr             jsr hex_dump
000046r 1               
000046r 1  20 rr rr             jsr verify_sorted
000049r 1  20 rr rr             jsr show_stats
00004Cr 1               
00004Cr 1                       ; ========== TEST 2: SELECTION SORT ==========
00004Cr 1  A9 rr                lda #<str_select
00004Er 1  85 rr                sta str_ptr
000050r 1  A9 rr                lda #>str_select
000052r 1  85 rr                sta str_ptr+1
000054r 1  20 rr rr             jsr print_string
000057r 1               
000057r 1  20 rr rr             jsr fill_random
00005Ar 1               
00005Ar 1  A9 rr                lda #<str_before
00005Cr 1  85 rr                sta str_ptr
00005Er 1  A9 rr                lda #>str_before
000060r 1  85 rr                sta str_ptr+1
000062r 1  20 rr rr             jsr print_string
000065r 1  20 rr rr             jsr hex_dump
000068r 1               
000068r 1  20 rr rr             jsr selection_sort
00006Br 1               
00006Br 1  A9 rr                lda #<str_after
00006Dr 1  85 rr                sta str_ptr
00006Fr 1  A9 rr                lda #>str_after
000071r 1  85 rr                sta str_ptr+1
000073r 1  20 rr rr             jsr print_string
000076r 1  20 rr rr             jsr hex_dump
000079r 1               
000079r 1  20 rr rr             jsr verify_sorted
00007Cr 1  20 rr rr             jsr show_stats
00007Fr 1               
00007Fr 1                       ; ========== TEST 3: SHELL SORT ==========
00007Fr 1  A9 rr                lda #<str_shell
000081r 1  85 rr                sta str_ptr
000083r 1  A9 rr                lda #>str_shell
000085r 1  85 rr                sta str_ptr+1
000087r 1  20 rr rr             jsr print_string
00008Ar 1               
00008Ar 1  20 rr rr             jsr fill_random
00008Dr 1               
00008Dr 1  A9 rr                lda #<str_before
00008Fr 1  85 rr                sta str_ptr
000091r 1  A9 rr                lda #>str_before
000093r 1  85 rr                sta str_ptr+1
000095r 1  20 rr rr             jsr print_string
000098r 1  20 rr rr             jsr hex_dump
00009Br 1               
00009Br 1  20 rr rr             jsr shell_sort
00009Er 1               
00009Er 1  A9 rr                lda #<str_after
0000A0r 1  85 rr                sta str_ptr
0000A2r 1  A9 rr                lda #>str_after
0000A4r 1  85 rr                sta str_ptr+1
0000A6r 1  20 rr rr             jsr print_string
0000A9r 1  20 rr rr             jsr hex_dump
0000ACr 1               
0000ACr 1  20 rr rr             jsr verify_sorted
0000AFr 1  20 rr rr             jsr show_stats
0000B2r 1               
0000B2r 1                       ; ========== FINAL SUMMARY ==========
0000B2r 1  A9 rr                lda #<str_done
0000B4r 1  85 rr                sta str_ptr
0000B6r 1  A9 rr                lda #>str_done
0000B8r 1  85 rr                sta str_ptr+1
0000BAr 1  20 rr rr             jsr print_string
0000BDr 1               
0000BDr 1  00                   brk
0000BEr 1  EA                   nop
0000BFr 1               .endproc
0000BFr 1               
0000BFr 1               ; ============================================
0000BFr 1               ; Fill array with random values
0000BFr 1               ; ============================================
0000BFr 1               .proc fill_random
0000BFr 1  A2 00                ldx #0
0000C1r 1               @loop:
0000C1r 1  20 rr rr             jsr random
0000C4r 1  9D 00 02             sta ARRAY_BASE,x
0000C7r 1  E8                   inx
0000C8r 1  E0 FF                cpx #ARRAY_SIZE
0000CAr 1  D0 F5                bne @loop
0000CCr 1  60                   rts
0000CDr 1               .endproc
0000CDr 1               
0000CDr 1               ; ============================================
0000CDr 1               ; Full hex dump of array (16 bytes per line)
0000CDr 1               ; Shows address: XX XX XX ... format
0000CDr 1               ; ============================================
0000CDr 1               .proc hex_dump
0000CDr 1  A9 00                lda #<ARRAY_BASE
0000CFr 1  85 rr                sta dump_ptr
0000D1r 1  A9 02                lda #>ARRAY_BASE
0000D3r 1  85 rr                sta dump_ptr+1
0000D5r 1               
0000D5r 1  A9 FF                lda #ARRAY_SIZE
0000D7r 1  85 rr                sta dump_cnt
0000D9r 1               
0000D9r 1               @line_loop:
0000D9r 1                       ; Print address
0000D9r 1  A5 rr                lda dump_ptr+1
0000DBr 1  20 rr rr             jsr print_hex
0000DEr 1  A5 rr                lda dump_ptr
0000E0r 1  20 rr rr             jsr print_hex
0000E3r 1  A9 3A                lda #':'
0000E5r 1  20 rr rr             jsr print_char
0000E8r 1  A9 20                lda #' '
0000EAr 1  20 rr rr             jsr print_char
0000EDr 1               
0000EDr 1                       ; Print 16 bytes per line
0000EDr 1  A0 00                ldy #0
0000EFr 1               @byte_loop:
0000EFr 1  B1 rr                lda (dump_ptr),y
0000F1r 1  20 rr rr             jsr print_hex
0000F4r 1  A9 20                lda #' '
0000F6r 1  20 rr rr             jsr print_char
0000F9r 1               
0000F9r 1  C6 rr                dec dump_cnt
0000FBr 1  F0 18                beq @done
0000FDr 1               
0000FDr 1  C8                   iny
0000FEr 1  C0 10                cpy #16
000100r 1  D0 ED                bne @byte_loop
000102r 1               
000102r 1                       ; Move pointer to next line
000102r 1  18                   clc
000103r 1  A5 rr                lda dump_ptr
000105r 1  69 10                adc #16
000107r 1  85 rr                sta dump_ptr
000109r 1  90 02                bcc @no_carry
00010Br 1  E6 rr                inc dump_ptr+1
00010Dr 1               @no_carry:
00010Dr 1               
00010Dr 1                       ; Print newline
00010Dr 1  A9 0D                lda #$0D
00010Fr 1  20 rr rr             jsr print_char
000112r 1  4C rr rr             jmp @line_loop
000115r 1               
000115r 1               @done:
000115r 1  A9 0D                lda #$0D
000117r 1  20 rr rr             jsr print_char
00011Ar 1  60                   rts
00011Br 1               .endproc
00011Br 1               
00011Br 1               ; ============================================
00011Br 1               ; Verify array is sorted
00011Br 1               ; ============================================
00011Br 1               .proc verify_sorted
00011Br 1  A2 00                ldx #0
00011Dr 1               @loop:
00011Dr 1  E0 FE                cpx #ARRAY_SIZE-1   ; Stop before last element
00011Fr 1  F0 19                beq @pass
000121r 1               
000121r 1  BD 00 02             lda ARRAY_BASE,x    ; Load array[x]
000124r 1  DD 01 02             cmp ARRAY_BASE+1,x  ; Compare with array[x+1]
000127r 1  F0 0E                beq @next           ; Equal is OK
000129r 1  90 0C                bcc @next           ; Less than is OK (ascending)
00012Br 1               
00012Br 1                       ; array[x] > array[x+1] = FAIL
00012Br 1  A9 rr                lda #<str_fail
00012Dr 1  85 rr                sta str_ptr
00012Fr 1  A9 rr                lda #>str_fail
000131r 1  85 rr                sta str_ptr+1
000133r 1  20 rr rr             jsr print_string
000136r 1  60                   rts
000137r 1               
000137r 1               @next:
000137r 1  E8                   inx
000138r 1  D0 E3                bne @loop
00013Ar 1               
00013Ar 1               @pass:
00013Ar 1  A9 rr                lda #<str_pass
00013Cr 1  85 rr                sta str_ptr
00013Er 1  A9 rr                lda #>str_pass
000140r 1  85 rr                sta str_ptr+1
000142r 1  20 rr rr             jsr print_string
000145r 1  60                   rts
000146r 1               .endproc
000146r 1               
000146r 1               ; ============================================
000146r 1               ; Show statistics (swaps, comparisons)
000146r 1               ; ============================================
000146r 1               .proc show_stats
000146r 1  A9 rr                lda #<str_swaps
000148r 1  85 rr                sta str_ptr
00014Ar 1  A9 rr                lda #>str_swaps
00014Cr 1  85 rr                sta str_ptr+1
00014Er 1  20 rr rr             jsr print_string
000151r 1  A5 rr                lda swap_count+1
000153r 1  20 rr rr             jsr print_hex
000156r 1  A5 rr                lda swap_count
000158r 1  20 rr rr             jsr print_hex
00015Br 1               
00015Br 1  A9 rr                lda #<str_compares
00015Dr 1  85 rr                sta str_ptr
00015Fr 1  A9 rr                lda #>str_compares
000161r 1  85 rr                sta str_ptr+1
000163r 1  20 rr rr             jsr print_string
000166r 1  A5 rr                lda compare_cnt+1
000168r 1  20 rr rr             jsr print_hex
00016Br 1  A5 rr                lda compare_cnt
00016Dr 1  20 rr rr             jsr print_hex
000170r 1               
000170r 1  A9 0D                lda #$0D
000172r 1  20 rr rr             jsr print_char
000175r 1  A9 0D                lda #$0D
000177r 1  20 rr rr             jsr print_char
00017Ar 1  60                   rts
00017Br 1               .endproc
00017Br 1               
00017Br 1               ; ============================================
00017Br 1               ; BUBBLE SORT - O(n²)
00017Br 1               ; Classic but slow - many swaps
00017Br 1               ; ============================================
00017Br 1               .proc bubble_sort
00017Br 1                       ; Reset counters
00017Br 1  64 rr                stz swap_count
00017Dr 1  64 rr                stz swap_count+1
00017Fr 1  64 rr                stz compare_cnt
000181r 1  64 rr                stz compare_cnt+1
000183r 1  64 rr                stz compare_cnt+2
000185r 1  64 rr                stz compare_cnt+3
000187r 1               
000187r 1  A9 FE                lda #ARRAY_SIZE-1
000189r 1  85 rr                sta i_idx       ; Outer loop count (n-1)
00018Br 1               
00018Br 1               @outer:
00018Br 1  A5 rr                lda i_idx
00018Dr 1  F0 35                beq @done       ; If i_idx is 0, we're done
00018Fr 1               
00018Fr 1  A2 00                ldx #0
000191r 1  86 rr                stx temp2       ; swapped flag = false
000193r 1               
000193r 1               @inner:
000193r 1                       ; Increment comparison counter
000193r 1  E6 rr                inc compare_cnt
000195r 1  D0 02                bne @no_inc1
000197r 1  E6 rr                inc compare_cnt+1
000199r 1               @no_inc1:
000199r 1               
000199r 1                       ; Compare adjacent elements
000199r 1  BD 00 02             lda ARRAY_BASE,x
00019Cr 1  DD 01 02             cmp ARRAY_BASE+1,x
00019Fr 1  90 15                bcc @no_swap    ; A < next, no swap needed
0001A1r 1  F0 13                beq @no_swap    ; A = next, no swap needed
0001A3r 1               
0001A3r 1                       ; Swap needed: A has larger value at [x], need to swap with [x+1]
0001A3r 1  48                   pha             ; Save larger value
0001A4r 1  BD 01 02             lda ARRAY_BASE+1,x  ; Get smaller value
0001A7r 1  9D 00 02             sta ARRAY_BASE,x    ; Store at position x
0001AAr 1  68                   pla
0001ABr 1  9D 01 02             sta ARRAY_BASE+1,x  ; Store larger at x+1
0001AEr 1               
0001AEr 1  E6 rr                inc temp2       ; swapped = true
0001B0r 1               
0001B0r 1                       ; Increment swap counter
0001B0r 1  E6 rr                inc swap_count
0001B2r 1  D0 02                bne @no_swap
0001B4r 1  E6 rr                inc swap_count+1
0001B6r 1               
0001B6r 1               @no_swap:
0001B6r 1  E8                   inx
0001B7r 1  E4 rr                cpx i_idx       ; Compare with shrinking boundary
0001B9r 1  D0 D8                bne @inner
0001BBr 1               
0001BBr 1                       ; If no swaps, array is sorted
0001BBr 1  A5 rr                lda temp2
0001BDr 1  F0 05                beq @done
0001BFr 1               
0001BFr 1  C6 rr                dec i_idx
0001C1r 1  4C rr rr             jmp @outer
0001C4r 1               
0001C4r 1               @done:
0001C4r 1  60                   rts
0001C5r 1               .endproc
0001C5r 1               
0001C5r 1               ; ============================================
0001C5r 1               ; SELECTION SORT - O(n²)
0001C5r 1               ; Fewer swaps than bubble sort
0001C5r 1               ; ============================================
0001C5r 1               .proc selection_sort
0001C5r 1                       ; Reset counters
0001C5r 1  64 rr                stz swap_count
0001C7r 1  64 rr                stz swap_count+1
0001C9r 1  64 rr                stz compare_cnt
0001CBr 1  64 rr                stz compare_cnt+1
0001CDr 1  64 rr                stz compare_cnt+2
0001CFr 1  64 rr                stz compare_cnt+3
0001D1r 1               
0001D1r 1  64 rr                stz i_idx       ; Start at 0
0001D3r 1               
0001D3r 1               @outer:
0001D3r 1  A5 rr                lda i_idx
0001D5r 1  C9 FE                cmp #ARRAY_SIZE-1
0001D7r 1  F0 4D                beq @done       ; Done when i reaches n-1
0001D9r 1               
0001D9r 1  85 rr                sta min_idx     ; Assume current is minimum
0001DBr 1               
0001DBr 1                       ; j = i + 1
0001DBr 1  18                   clc
0001DCr 1  69 01                adc #1
0001DEr 1  85 rr                sta j_idx
0001E0r 1               
0001E0r 1               @inner:
0001E0r 1  A5 rr                lda j_idx
0001E2r 1  C9 FF                cmp #ARRAY_SIZE
0001E4r 1  F0 1B                beq @do_swap    ; j reached end, do swap
0001E6r 1               
0001E6r 1                       ; Increment comparison counter
0001E6r 1  E6 rr                inc compare_cnt
0001E8r 1  D0 02                bne @no_inc1
0001EAr 1  E6 rr                inc compare_cnt+1
0001ECr 1               @no_inc1:
0001ECr 1               
0001ECr 1                       ; Compare array[j] with array[min_idx]
0001ECr 1  A6 rr                ldx min_idx
0001EEr 1  BD 00 02             lda ARRAY_BASE,x
0001F1r 1  A6 rr                ldx j_idx
0001F3r 1  DD 00 02             cmp ARRAY_BASE,x
0001F6r 1  90 04                bcc @next       ; min < current, keep min
0001F8r 1  F0 02                beq @next
0001FAr 1               
0001FAr 1                       ; Found new minimum
0001FAr 1  86 rr                stx min_idx
0001FCr 1               
0001FCr 1               @next:
0001FCr 1  E6 rr                inc j_idx
0001FEr 1  4C rr rr             jmp @inner
000201r 1               
000201r 1               @do_swap:
000201r 1                       ; Swap array[i] with array[min_idx] if different
000201r 1  A5 rr                lda i_idx
000203r 1  C5 rr                cmp min_idx
000205r 1  F0 1A                beq @no_swap
000207r 1               
000207r 1  A6 rr                ldx i_idx
000209r 1  A4 rr                ldy min_idx
00020Br 1  BD 00 02             lda ARRAY_BASE,x
00020Er 1  85 rr                sta temp
000210r 1  B9 00 02             lda ARRAY_BASE,y
000213r 1  9D 00 02             sta ARRAY_BASE,x
000216r 1  A5 rr                lda temp
000218r 1  99 00 02             sta ARRAY_BASE,y
00021Br 1               
00021Br 1                       ; Increment swap counter
00021Br 1  E6 rr                inc swap_count
00021Dr 1  D0 02                bne @no_swap
00021Fr 1  E6 rr                inc swap_count+1
000221r 1               
000221r 1               @no_swap:
000221r 1  E6 rr                inc i_idx
000223r 1  4C rr rr             jmp @outer
000226r 1               
000226r 1               @done:
000226r 1  60                   rts
000227r 1               .endproc
000227r 1               
000227r 1               ; ============================================
000227r 1               ; SHELL SORT - O(n log n) to O(n²)
000227r 1               ; Much faster than bubble/selection
000227r 1               ; ============================================
000227r 1               .proc shell_sort
000227r 1                       ; Reset counters
000227r 1  64 rr                stz swap_count
000229r 1  64 rr                stz swap_count+1
00022Br 1  64 rr                stz compare_cnt
00022Dr 1  64 rr                stz compare_cnt+1
00022Fr 1  64 rr                stz compare_cnt+2
000231r 1  64 rr                stz compare_cnt+3
000233r 1               
000233r 1                       ; Start with gap = ARRAY_SIZE/2
000233r 1  A9 7F                lda #ARRAY_SIZE/2
000235r 1  85 rr                sta gap
000237r 1               
000237r 1               @gap_loop:
000237r 1  A5 rr                lda gap
000239r 1  F0 4D                beq @done
00023Br 1  85 rr                sta i_idx       ; i = gap
00023Dr 1               
00023Dr 1               @outer:
00023Dr 1  A5 rr                lda i_idx
00023Fr 1  C9 FF                cmp #ARRAY_SIZE
000241r 1  F0 40                beq @next_gap   ; i >= ARRAY_SIZE, reduce gap
000243r 1               
000243r 1  A6 rr                ldx i_idx
000245r 1  BD 00 02             lda ARRAY_BASE,x
000248r 1  85 rr                sta temp        ; temp = array[i]
00024Ar 1               
00024Ar 1  86 rr                stx j_idx       ; j = i
00024Cr 1               
00024Cr 1               @inner:
00024Cr 1                       ; Check if j >= gap
00024Cr 1  A5 rr                lda j_idx
00024Er 1  C5 rr                cmp gap
000250r 1  90 25                bcc @insert     ; j < gap, done with inner
000252r 1               
000252r 1                       ; Increment comparison counter
000252r 1  E6 rr                inc compare_cnt
000254r 1  D0 02                bne @no_inc1
000256r 1  E6 rr                inc compare_cnt+1
000258r 1               @no_inc1:
000258r 1               
000258r 1                       ; Calculate j - gap
000258r 1  A5 rr                lda j_idx
00025Ar 1  38                   sec
00025Br 1  E5 rr                sbc gap
00025Dr 1  AA                   tax             ; X = j - gap
00025Er 1               
00025Er 1                       ; Compare array[j-gap] with temp
00025Er 1  BD 00 02             lda ARRAY_BASE,x
000261r 1  C5 rr                cmp temp
000263r 1  90 12                bcc @insert     ; array[j-gap] < temp, done
000265r 1  F0 10                beq @insert
000267r 1               
000267r 1                       ; Shift array[j-gap] to array[j]
000267r 1  A4 rr                ldy j_idx
000269r 1  99 00 02             sta ARRAY_BASE,y
00026Cr 1  86 rr                stx j_idx       ; j = j - gap
00026Er 1               
00026Er 1                       ; Increment swap counter
00026Er 1  E6 rr                inc swap_count
000270r 1  D0 DA                bne @inner
000272r 1  E6 rr                inc swap_count+1
000274r 1  4C rr rr             jmp @inner
000277r 1               
000277r 1               @insert:
000277r 1                       ; array[j] = temp
000277r 1  A6 rr                ldx j_idx
000279r 1  A5 rr                lda temp
00027Br 1  9D 00 02             sta ARRAY_BASE,x
00027Er 1               
00027Er 1                       ; i++
00027Er 1  E6 rr                inc i_idx
000280r 1  4C rr rr             jmp @outer
000283r 1               
000283r 1               @next_gap:
000283r 1                       ; gap = gap / 2
000283r 1  46 rr                lsr gap
000285r 1  4C rr rr             jmp @gap_loop
000288r 1               
000288r 1               @done:
000288r 1  60                   rts
000289r 1               .endproc
000289r 1               
000289r 1               ; ============================================
000289r 1               ; 16-bit LFSR Random Number Generator
000289r 1               ; ============================================
000289r 1               .proc random
000289r 1  A5 rr                lda rand_seed
00028Br 1  0A                   asl a
00028Cr 1  26 rr                rol rand_seed+1
00028Er 1  90 0A                bcc @no_eor
000290r 1  49 39                eor #$39
000292r 1  48                   pha
000293r 1  A5 rr                lda rand_seed+1
000295r 1  49 B4                eor #$B4
000297r 1  85 rr                sta rand_seed+1
000299r 1  68                   pla
00029Ar 1               @no_eor:
00029Ar 1  85 rr                sta rand_seed
00029Cr 1  60                   rts
00029Dr 1               .endproc
00029Dr 1               
00029Dr 1               ; ============================================
00029Dr 1               ; Print hex byte in A
00029Dr 1               ; ============================================
00029Dr 1               .proc print_hex
00029Dr 1  48                   pha
00029Er 1  4A                   lsr a
00029Fr 1  4A                   lsr a
0002A0r 1  4A                   lsr a
0002A1r 1  4A                   lsr a
0002A2r 1  20 rr rr             jsr @nibble
0002A5r 1  68                   pla
0002A6r 1  29 0F                and #$0F
0002A8r 1               @nibble:
0002A8r 1  C9 0A                cmp #10
0002AAr 1  90 02                bcc @digit
0002ACr 1  69 06                adc #6
0002AEr 1  69 30        @digit: adc #'0'
0002B0r 1  20 rr rr             jsr print_char
0002B3r 1  60                   rts
0002B4r 1               .endproc
0002B4r 1               
0002B4r 1               ; ============================================
0002B4r 1               ; Print character in A
0002B4r 1               ; ============================================
0002B4r 1               .proc print_char
0002B4r 1  20 D2 FF             jsr CHROUT
0002B7r 1  60                   rts
0002B8r 1               .endproc
0002B8r 1               
0002B8r 1               ; ============================================
0002B8r 1               ; Print null-terminated string
0002B8r 1               ; ============================================
0002B8r 1               .proc print_string
0002B8r 1  A0 00                ldy #0
0002BAr 1               @loop:
0002BAr 1  B1 rr                lda (str_ptr),y
0002BCr 1  F0 06                beq @done
0002BEr 1  20 D2 FF             jsr CHROUT
0002C1r 1  C8                   iny
0002C2r 1  D0 F6                bne @loop
0002C4r 1  60           @done:  rts
0002C5r 1               .endproc
0002C5r 1               
0002C5r 1               ; ============================================
0002C5r 1               ; DATA SECTION
0002C5r 1               ; ============================================
0002C5r 1               banner:
0002C5r 1  0D 3D 3D 3D          .byte $0D, "================================", $0D
0002C9r 1  3D 3D 3D 3D  
0002CDr 1  3D 3D 3D 3D  
0002E7r 1  20 20 36 35          .byte "  65C02 MEMORY SORT STRESS TEST", $0D
0002EBr 1  43 30 32 20  
0002EFr 1  4D 45 4D 4F  
000307r 1  20 20 36 34          .byte "  64 bytes x 3 algorithms", $0D
00030Br 1  20 62 79 74  
00030Fr 1  65 73 20 78  
000321r 1  3D 3D 3D 3D          .byte "================================", $0D, $0D, 0
000325r 1  3D 3D 3D 3D  
000329r 1  3D 3D 3D 3D  
000344r 1               
000344r 1               str_bubble:
000344r 1  3E 3E 20 42          .byte ">> BUBBLE SORT", $0D, 0
000348r 1  55 42 42 4C  
00034Cr 1  45 20 53 4F  
000354r 1               str_select:
000354r 1  3E 3E 20 53          .byte ">> SELECTION SORT", $0D, 0
000358r 1  45 4C 45 43  
00035Cr 1  54 49 4F 4E  
000367r 1               str_shell:
000367r 1  3E 3E 20 53          .byte ">> SHELL SORT", $0D, 0
00036Br 1  48 45 4C 4C  
00036Fr 1  20 53 4F 52  
000376r 1               
000376r 1               str_before:
000376r 1  42 65 66 6F          .byte "Before:", $0D, 0
00037Ar 1  72 65 3A 0D  
00037Er 1  00           
00037Fr 1               str_after:
00037Fr 1  41 66 74 65          .byte "After:", $0D, 0
000383r 1  72 3A 0D 00  
000387r 1               
000387r 1               str_pass:
000387r 1  56 65 72 69          .byte "Verify: PASS", $0D, 0
00038Br 1  66 79 3A 20  
00038Fr 1  50 41 53 53  
000395r 1               str_fail:
000395r 1  56 65 72 69          .byte "Verify: FAIL!", $0D, 0
000399r 1  66 79 3A 20  
00039Dr 1  46 41 49 4C  
0003A4r 1               
0003A4r 1               str_swaps:
0003A4r 1  53 77 61 70          .byte "Swaps: $", 0
0003A8r 1  73 3A 20 24  
0003ACr 1  00           
0003ADr 1               str_compares:
0003ADr 1  20 43 6D 70          .byte " Cmp: $", 0
0003B1r 1  3A 20 24 00  
0003B5r 1               
0003B5r 1               str_done:
0003B5r 1  3D 3D 3D 3D          .byte "================================", $0D
0003B9r 1  3D 3D 3D 3D  
0003BDr 1  3D 3D 3D 3D  
0003D6r 1  41 4C 4C 20          .byte "ALL SORTS COMPLETE!", $0D
0003DAr 1  53 4F 52 54  
0003DEr 1  53 20 43 4F  
0003EAr 1  3D 3D 3D 3D          .byte "================================", $0D, 0
0003EEr 1  3D 3D 3D 3D  
0003F2r 1  3D 3D 3D 3D  
00040Br 1               
